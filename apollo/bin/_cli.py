import argparse
import importlib
import inspect
import pkgutil
import sys


def _module(name=None, index=2):
    '''Get a module.

    If ``name`` is a string, interpret it as a dotted import path to the module.

    If ``name`` is none, get the module of a caller, dertermined by ``index``.
    The default value of 2 means the module of the caller's caller.
    '''
    if name is None:
        stack = inspect.stack()
        frame = stack[index].frame
        return inspect.getmodule(frame)
    else:
        return importlib.import_module(name)


def submodules(name=None, _index=2):
    '''Iterate over submodules.

    If ``name`` is a string, interpret it as a dotted import path to the module.

    If ``name`` is none, iterate over the submodules relative to the caller's
    module.
    '''
    module = _module(name, _index)
    prefix = f'{module.__name__}.'
    paths = module.__path__
    for mod_info in pkgutil.iter_modules(paths, prefix):
        mod_name = mod_info.name
        mod = importlib.import_module(mod_name)
        yield mod


def subcommands(name=None, _index=3):
    '''Return a dictionary of subcommands.

    A subcommand is any submodule with a function called ``main``.

    If ``name`` is a string, interpret it as a dotted import path to a module.
    Subcommands are searched relative to that module.

    If ``name`` is none, this function searches for submodules relative to the
    caller's module.
    '''
    commands = {}
    for mod in submodules(name, _index=_index):
        if hasattr(mod, 'main'):
            cmd_name = mod.__name__.rsplit('.', 1)[-1]
            commands[cmd_name] = mod.main
    return commands


def _description(text, cmds):
    '''A wrapper to create description help text.
    '''
    text += '\n\n'
    text += 'subcommands:\n'
    for cmd in cmds:
        text += f'  {cmd}\n'
    return text


def _from_commands(d):
    '''A type parser for :class:`argparse.ArgumentParser` that converts
    arguments according to a dictionary.
    '''
    def _convert(name):
        try:
            return (name, d[name])
        except KeyError:
            print('invalid command:', name, file=sys.stderr)
            print('valid commands are:', file=sys.stderr)
            for cmd_name in d.keys():
                print('    ', cmd_name, file=sys.stderr)
            sys.exit(1)
    return _convert


def subcommand_parser(**kwargs):
    '''Create an argument parser for meta-commands.
    '''
    cmds = subcommands(_index=4)

    description = kwargs.get('description', 'a meta-command')
    kwargs['description'] = _description(description, cmds)
    kwargs['formatter_class'] = argparse.RawDescriptionHelpFormatter

    parser = argparse.ArgumentParser(**kwargs)

    parser.add_argument(
        'command',
        metavar='COMMAND',
        type=_from_commands(cmds),
        help='the subcommand to execute',
    )

    parser.add_argument(
        'argv',
        metavar='...',  # Matches the usage string generated by argparse.
        nargs=argparse.REMAINDER,
        help='additional arguments are forwarded to the subcommand'
    )

    return parser


def execute_subcommand(args):
    '''Execute a subcommand.

    Arguments:
        args (Namespace):
            The arguments parsed by an :class:`argparse.ArgumentParser`. That
            parser should be created by :func:`subcommand_parser`.
    '''
    # The argument stores both the name and the function it maps to.
    cmd_name, cmd = args.command

    # HACK: To set the program name automatically, we update `sys.argv[0]`
    sys.argv[0] = f'{sys.argv[0]} {cmd_name}'

    # Execute the command.
    cmd(args.argv)
