import argparse
import logging
import multiprocessing as mp
import os
import sys

from apollo import models, storage, casts
from apollo.models.base import list_trained_models
from apollo.models.base import load as load_model
from apollo.output import write_csv, write_json


def run_model(model_name, reftime, format='json'):
    '''Execute a model by name.

    Arguments:
        model_name (str):
            The name of the model to execute.
        reftime (pandas.Timestamp):
            The reftime to evaluate.
        format (str):
            The format of the output. One of ``'json'`` or ``'csv'``.
    '''
    logging.info(f'Loading model "{model_name}"...')
    model = load_model(model_name)

    logging.info('Generating predictions...')
    forecast = model.forecast(reftime)

    # TODO: The formatted time should be ISO format.
    # Changing this might effect the `forecast-to-html` command.
    formatted_reftime = reftime.strftime('%Y_%m_%d-%H:%M')
    first_hour = model.target_hours[0]
    last_hour = model.target_hours[-1]

    logging.info('Writing predictions to disk...')

    description = f'Predicted irradiance for {model.target} ' \
                  f'for future hours {first_hour} through {last_hour}. ' \
                  f'Prediction generated by a {model.__class__.__name__} model.'

    if format == 'csv':
        output_file = write_csv(
            forecast=forecast,
            name=f'{model_name}-{formatted_reftime}',
        )
    else:
        output_file = write_json(
            forecast=forecast,
            reftime=reftime,
            source=model_name,
            name=f'{model_name}-{formatted_reftime}',
            description=description,
        )

    logging.info(f'Wrote {output_file}')


def main(argv=None):
    parser = argparse.ArgumentParser(
        description='Generate a prediction from a trained Apollo models.',
    )

    parser.add_argument(
        'models',
        metavar='MODEL',
        type=str,
        nargs='*',
        help='the name of the model(s) to execute',
    )

    parser.add_argument(
        '--all',
        action='store_true',
        help='execute all models',
    )

    parser.add_argument(
        '--format',
        type=str,
        choices=('csv', 'json'),
        default='json',
        help='the output format'
    )

    parser.add_argument(
        '-j',
        '--jobs',
        type=int,
        default=os.cpu_count(),
        help='the number of models to execute in parallel (defaults to the number of CPUs)',
    )

    selectors = parser.add_mutually_exclusive_group()

    selectors.add_argument(
        '-t',
        '--reftime',
        metavar='TIMESTAMP',
        default='now',
        help='make a prediction for the given reftime',
    )

    # TODO: Add more selectors to be consistent with other Apollo CLIs.
    # This requires our models to be more Scikit-learn compatible (#65).
    # With multiple selectors, we can't set a default for argparse.

    args = parser.parse_args(argv)
    all_models = list_trained_models()
    models = all_models if args.all else args.models
    reftime = casts.utc_timestamp(args.reftime).floor('6h')

    # Ensure `--all` is used without any explicit models.
    if args.all and not len(args.models) == 0:
        logging.error('At least one model name or the --all option must be given.')
        sys.exit(1)

    # Ensure that all models actually exist.
    for model_name in models:
        if model_name not in all_models:
            logging.error(f'Unknown model: {model_name}')
            sys.exit(1)

    # If given `--all`, ensure that at least one model exists.
    if len(models) == 0:
        logging.error(f'No trained models in {storage.get_root()}')
        sys.exit(1)

    # Execute the models in a multiprocessing pool.
    pool = mp.Pool(args.jobs, maxtasksperchild=1)
    for model_name in models:
        pool.apply_async(run_model, kwargs={
            'model_name': model_name,
            'reftime': reftime,
            'format': args.format
        })
    pool.close()
    pool.join()


if __name__ == '__main__':
    main()
