# -*- coding: utf-8 -*-
''' Generates user-friendly HTML files from JSON-serialized forecasts

A forecast generated by Apollo is typically saved in JSON format. The JSON file
consists of  tabular data together with metadata describing the names and units of the
output variables as well as the reference time and temporal range of the forecast.
The raw JSON is not easily understood by users, and so it is instead formatted and
presented in an HTML file.

This script is intended to be run whenever new forecasts are generated.

A sample JSON formatted forecast is given below.

.. code-block:: python

    {
    	"source":"rf_test1",
    	"name":"Random Forest Test Forecast",
    	"description":"Predicted irradiance for UGABPOA1IRR for future hours 1 through 24. Prediction generated by a DecisionTree model.",
    	"targets":"UGABPOA1IRR",
    	"location":[33.9052058,-83.382608],
    	"reftime":1510531200000,
    	"site":"UGA-C-POA-1-IRR",
    	"created":1550736650906,
    	"start":1510142400000,
    	"stop":1510228800000,
    	"columns":[
    		{"label":"TIMESTAMP","units":"","description":"","type":"datetime"},
    		{"label":"UGA-C-POA-1-IRR","units":"w/m2","description":"","type":"number"}
    		],
    	"rows":[
    		["2017-11-08 12:00:00",6.065183055555549],
    		["2017-11-08 13:00:00",31.46784888888889],
    		["2017-11-08 14:00:00",68.25919000000005],
    		["2017-11-08 15:00:00",90.45589760237971],
    		["2017-11-08 16:00:00",50.2633881944444],
    		["2017-11-08 17:00:00",22.679933869949444],
    		["2017-11-08 18:00:00",45.70434916666664],
    		["2017-11-08 19:00:00",34.95386999999995],
    		["2017-11-08 20:00:00",27.662586944444463],
    		["2017-11-08 21:00:00",11.051701111111129],
    		["2017-11-08 22:00:00",73.62441263888886],
    		["2017-11-08 23:00:00",5.668792307449482],
    		["2017-11-09 00:00:00",5.409829861111108],
    		["2017-11-09 01:00:00",4.422578055555556],
    		["2017-11-09 02:00:00",2.021209444444444],
    		["2017-11-09 03:00:00",1.4476183333333374],
    		["2017-11-09 04:00:00",0.0],
    		["2017-11-09 05:00:00",-0.0036365277777777776],
    		["2017-11-09 06:00:00",12.723052361111101],
    		["2017-11-09 07:00:00",4.422578055555556],
    		["2017-11-09 08:00:00",28.37874833333334],
    		["2017-11-09 09:00:00",4.993746944444455],
    		["2017-11-09 10:00:00",0.0],
    		["2017-11-09 11:00:00",0.03728083333333331],
    		["2017-11-09 12:00:00",0.41544999999999954]
    		]}

To generate an HTML file, the JSON is inserted into a preexisting HTML template
(it is parsed and stored in a Javascript variable) and the result
is saved. The saved file can then be served as a static file to end users.
An index file (``index.html``), containing links to all of the generated HTML
forecasts, is also written.

The JSON file contents replace the string ``${model}`` in the HTML template.
Similarly, the index data replaces ``${modelindex}`` in the index template.

Usage
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::
    usage: __main__.py forecast-to-html [-h] [--in INPUT_DIR] [--out OUTPUT_DIR]
                                    [--log {DEBUG,INFO,WARNING,ERROR}]

    Convert JSON forecast files to user-friendly HTML

    optional arguments:
      -h, --help            show this help message and exit
      --in INPUT_DIR, -i INPUT_DIR
            The directory containing JSON forecasts to process.
      --out OUTPUT_DIR, -o OUTPUT_DIR
            The directory to write the generated HTML files.
      --log {DEBUG,INFO,WARN,ERROR}
            Sets the log level. Default is INFO

::

    usage: python -m apollo forecast-to-html [-h] -i path/to.input -o path/to/output

    arguments:
      -h, --help            show this help message and exit
      -i in, --in in        the directory containing JSON forecasts for process.
      -o out, --out out     the directory to store the generated HTML files.
      --log LOG             Sets the log level. One of INFO, DEBUG, ERROR, etc.
                            Default is INFO


When the script is run, the input directory provided is scanned for JSON files.
For each one found, its contents are read and substituted for ``${model}`` in
the HTML template string.
The result is then saved to the specified output directory.
The name of each generated file is stored, and this is used to generate
``index.html``, which is also stored in the output directory.

'''

import argparse
import os
import json
import datetime
import logging
from string import Template
from pathlib import Path
import pkg_resources

import apollo.storage

DEFAULT_INDEX_FILE = 'index.html'

MODEL_TEMPLATE_PATH = 'assets/templates/forecast.html'  # path to templates
INDEX_TEMPLATE_PATH = 'assets/templates/index.html'
JS_CSS_PATH = Path('assets/html/')  # path to js and css files
TEMPLATE_JS_CSS = ('explorer.css', 'explorer_ui.js', 'date_utils.js')


def process_directory(in_dir, out_dir):
    ''' Converts a directory of JSON-encoded forecasts to HTML files

    The contents of each JSON file is converted to a javascript dictionary and
    combined with an HTML template to yield an HTML document viewable by end users.
    An ``index.html`` page is also  produced.

    In the HTML template, the key ``${model`` is replaced with the converted JSON content.
    Similarly, in the index template, the key ``${modelindex}`` is replaced.

    Arguments:
        in_dir (str): The directory holding the JSON files to process.
        out_dir (str): The directory to store the generated HTML documents.
    '''
    forecasts = []
    template_str = pkg_resources.resource_string(
        'apollo',
        MODEL_TEMPLATE_PATH
    ).decode("utf-8")
    forecast_template = Template(template_str)

    for root, dirs, files in os.walk(in_dir):
        for filename in files:
            if filename.endswith(".json"):
                logging.info("processing " + str(filename))
                infile = Path(root) / filename
                summary, outfile, result_string = process_json_file(
                    infile,
                    forecast_template,
                    out_dir
                )
                forecasts.append(summary)

    index = json.dumps(forecasts)
    index_temp_str = pkg_resources.resource_string(
        'apollo',
        INDEX_TEMPLATE_PATH
    ).decode('utf-8')
    index_template = Template(index_temp_str)
    index_str = index_template.substitute(modelindex=index)

    # write the index file
    out_dir = Path(out_dir)
    with open(out_dir / DEFAULT_INDEX_FILE, 'w') as f:
        f.write(index_str)

    # copy the js and css files
    for filename in TEMPLATE_JS_CSS:
        path = JS_CSS_PATH / filename
        file_str = pkg_resources.resource_string(
            'apollo',
            str(path)
        ).decode("utf-8")
        with open(Path(out_dir) / filename, 'w') as f:
            f.write(file_str)


def process_json_file(infile, template, out_dir=None):
    ''' Read in the JSON contents of a file, substitute it into a template string,
    and write the results to an HTML file in the given output directory.
    The name of the HTML file is constructed from the input forecast data.

    The resulting string is returned, together with the summary JSON (the JSON
    with the rows of forecast values removed) and the name of the output file.

    If the output directory is ``None``, then no output file is written and
    ``None`` is returned for the output file.

    Arguments:
        infile (str or :class:`pathlib.Path`):
            The JSON file to process.
        out_dir (str or :class:`pathlib.Path`):
            The directory to store the generated HTML document.
        template (:class:`string.Template`):
            The string template to substitute the processed JSON into.

    Returns:
         (tuple):
             A tuple containing the JSON content read in (without rows of forecast values),
             the output file (:class:`pathlib.Path`), and the actual string written.

    '''
    with open(infile, 'r') as f:
        file_contents = f.read()

    data = json.loads(file_contents)
    summary = _extract_summary(data)
    result_string = template.substitute(model=file_contents)

    outfile = None
    if out_dir:
        htmlfile = _get_file_name(data) + ".html"
        outfile = Path(out_dir) / htmlfile
        summary['href'] = htmlfile
        with open(outfile, 'w') as out_file:
            out_file.write(result_string)

    return summary, result_string, outfile


def _get_file_name(data):
    undefined = "UNDEFINED"
    source = ""
    created = undefined
    keys = data.keys()
    if 'source' in keys:
        source = data['source']
    if 'reftime' in keys:
        created = data['created']
        created = datetime.datetime.fromtimestamp(created / 1e3)
        created = str(created).replace(":", "_")
    elif 'created' in keys:
        created = data['created']
        created = datetime.datetime.fromtimestamp(created / 1e3)
        created = str(created).replace(":", "_")
    return source + "_" + created


def _extract_summary(data):
    results = {}
    for k in data.keys():
        if k != "rows":
            results[k] = data[k];
    return results


def main(argv=None):
    parser = argparse.ArgumentParser(
        description='Convert JSON forecast files to user-friendly HTML')
    parser.add_argument(
        '--in',
        '-i',
        dest='input_dir',
        type=str,
        default=apollo.storage.get('output/json'),
        help='The directory containing JSON forecasts to process.')
    parser.add_argument(
        '--out',
        '-o',
        dest='output_dir',
        type=str,
        default=apollo.storage.get('assets/html/forecasts'),
        help='The directory to write the generated HTML files.')
    parser.add_argument(
        '--log',
        type=str,
        default='INFO',
        choices=('DEBUG', 'INFO', 'WARN', 'ERROR'),
        help='Sets the log level. Default is INFO')

    args = parser.parse_args(argv)

    logging.basicConfig(
        format='[{asctime}] {levelname}: {message}',
        style='{',
        level=args.log)

    logging.info(" * in:" + str(args.input_dir))
    logging.info(" * out:" + str(args.output_dir))

    process_directory(Path(args.input_dir), Path(args.output_dir))


if __name__ == "__main__":
    main()


