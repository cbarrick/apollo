# -*- coding: utf-8 -*-
"""Command line script to generate HTML files from JSON forecast files. 

A forecast generated by Apollo is typically saved in JSON format. The JSON file 
consists of  tabular data together with metadata describing the names and units of the 
output variables as well as the reference time and temporal range of the forecast. 
The raw JSON is not easily understood by users, and so it is instead formatted and 
presented in an HTML file. 

This script is intended to be run whenever new forecasts are generated. 

A sample JSON formatted forecast is given below. 

.. code-block:: python

    {
    	"source":"rf_test1",
    	"name":"Random Forest Test Forecast",
    	"description":"Predicted irradiance for UGABPOA1IRR for future hours 1 through 24. Prediction generated by a DecisionTree model.",
    	"targets":"UGABPOA1IRR",
    	"location":[33.9052058,-83.382608],
    	"reftime":1510531200000,
    	"site":"UGA-C-POA-1-IRR",
    	"created":1550736650906,
    	"start":1510142400000,
    	"stop":1510228800000,
    	"columns":[
    		{"label":"TIMESTAMP","units":"","description":"","type":"datetime"},
    		{"label":"UGA-C-POA-1-IRR","units":"w/m2","description":"","type":"number"}
    		],
    	"rows":[
    		["2017-11-08 12:00:00",6.065183055555549],
    		["2017-11-08 13:00:00",31.46784888888889],
    		["2017-11-08 14:00:00",68.25919000000005],
    		["2017-11-08 15:00:00",90.45589760237971],
    		["2017-11-08 16:00:00",50.2633881944444],
    		["2017-11-08 17:00:00",22.679933869949444],
    		["2017-11-08 18:00:00",45.70434916666664],
    		["2017-11-08 19:00:00",34.95386999999995],
    		["2017-11-08 20:00:00",27.662586944444463],
    		["2017-11-08 21:00:00",11.051701111111129],
    		["2017-11-08 22:00:00",73.62441263888886],
    		["2017-11-08 23:00:00",5.668792307449482],
    		["2017-11-09 00:00:00",5.409829861111108],
    		["2017-11-09 01:00:00",4.422578055555556],
    		["2017-11-09 02:00:00",2.021209444444444],
    		["2017-11-09 03:00:00",1.4476183333333374],
    		["2017-11-09 04:00:00",0.0],
    		["2017-11-09 05:00:00",-0.0036365277777777776],
    		["2017-11-09 06:00:00",12.723052361111101],
    		["2017-11-09 07:00:00",4.422578055555556],
    		["2017-11-09 08:00:00",28.37874833333334],
    		["2017-11-09 09:00:00",4.993746944444455],
    		["2017-11-09 10:00:00",0.0],
    		["2017-11-09 11:00:00",0.03728083333333331],
    		["2017-11-09 12:00:00",0.41544999999999954]
    		]}
		
To generate an HTML file, the JSON is inserted into a preexisting HTML template 
(it is parsed and stored in a Javascript variable) and the result 
is saved. The saved file can then be served as a static file to end users. 
An index file (``index.html``), containing links to all of the generated HTML 
forecasts, is also written.

The JSON file contents replace the string ``${model}`` in the HTML template. 
Similarly, the index data replaces ``${modelindex}`` in the index template. 

Usage
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::
    
    usage: html.py [-h] -i in -o out -n index -t index [--log LOG]
    
    Utility function generating HTML files from JSON forecast files (the output of
    machine learning models). 
    
    arguments:
      -h, --help            show this help message and exit
      -i in, --in in        the directory containing JSON forecasts for process.
      -o out, --out out     the directory to store the generated HTML files.
      -n index, --index index
                            the name of the index file ("index.html" by default).
      -t index, --template index
                            the name of the template file to insert the JSON into
                            ("template.html" by default).
      --log LOG             Sets the log level. One of INFO, DEBUG, ERROR, etc.
                            Default is INFO


When the script is run, the input directory provided is scanned for JSON files. 
For each one found, its contents are read and substituted for ``${model}`` in 
the HTML template string. The result is then saved to the specified output directory. 
The name of each generated file is stored, and this is used to generate ``index.html``, which
is also stored in the output directory. 


Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:: 
    
    $ python -m apollo.server.html -i forecast_json -o html/apollo/forecasts --index schemas/html/index.html --template schemas/html/forecast.html
    [2019-03-21 18:15:22,503] INFO:  * in:forecast_json
    [2019-03-21 18:15:22,503] INFO:  * out:html/apollo/forecasts
    [2019-03-21 18:15:22,505] INFO:  * index:schemas/html/index.html
    [2019-03-21 18:15:22,507] INFO:  * template:schemas/html/forecast.html

"""
import argparse
import os
import json
import datetime
import logging
from string import Template 
from pathlib import Path
import apollo.assets.api as assets

INDEX_FILE_NAME = "index.html"

TEMPLATES_PATH = 'assets/templates/'  #path to templates
JS_CSS_PATH = 'assets/html/'  #path to js and css files
TEMPLATE_JS_CSS = ('explorer.css', 'explorer_ui.js', 'date_utils.js')

def process_directory(in_dir, out_dir, index_template_file, model_template_file):
    """Processes a directory of JSON encoded forecasts, producing HTML files for each. 
    
    The contents of each JSON file is converted to a javascript dictionary and combined with 
    an HTML template to yield an HTML document viewable by end users. 
    An ``index.html`` page is also  produced. 

    In the HTML template, the key ``${model`` is replaced with the converted JSON content. 
    Similarly, in the index template, the key ``${modelindex}`` is replaced.

    Arguments:
        in_dir (str): The directory holding the JSON files to process. 
        out_dir (str): The directory to store the generated HTML documents. 
        index_template_file (str): The path to the ``index.html`` template. 
        model_template_file (str): The path to the HTML forecast template. 
    """
    forecasts = []
    #forecast_template = Template(_file_to_string(model_template_file))
    template_str = assets.get_asset_string(TEMPLATES_PATH + str(model_template_file))
    forecast_template = Template(template_str)
  
    for root, dirs, files in os.walk(in_dir):
        for filename in files:
            if filename.endswith(".json"):
                logging.info("processing " +str(filename))
                infile = Path(root)/ filename
                summary, outfile, result_string = process_json_file(infile, forecast_template, out_dir)
                forecasts.append(summary)
    index = json.dumps(forecasts)
    #index_template = Template(_file_to_string(index_template_file))
    index_temp_str = assets.get_asset_string(TEMPLATES_PATH + str(index_template_file))
    index_template = Template(index_temp_str)
    index_str = index_template.substitute(modelindex=index)
    _string_to_file(out_dir/INDEX_FILE_NAME,index_str)
    _copy_js_css(out_dir)
     
    
    
    
def process_json_file(infile, template, out_dir =None):
    """Read in the JSON contents of a file, substitute it into a template string, 
    and write the results to an HTML file in the given output directory. 
    The name of the HTML file is constructed from the input forecast data. 
    
    The resulting string is returned, together with the summary JSON (the JSON with 
    the rows of forecast values removed) and the name of the output file. 
    
    If the output directory is ``None``, then no output file is written and
    ``None`` is returned for the output file.

    Arguments:
        infile (str or :class:`pathlib.Path`): The JSON file to process. 
        out_dir (str or :class:`pathlib.Path`): The directory to store the generated HTML document. 
        template (:class:`string.Template`): The string template to substitute the processed JSON into. 

    Returns: 
         (tuple):
             A tuple containing the JSON content read in (without rows of forecast values),
             the output file (:class:`pathlib.Path`), and the actual string written.  

    """
    filestr = _file_to_string(infile)
    result_string = template.substitute(model=filestr)
    outfile = None
    if out_dir: 
        data = json.loads(filestr)
        summary = _extract_summary(data)
        htmlfile = _get_file_name(data)+".html"
        outfile = Path(out_dir)/htmlfile
        summary['href'] = htmlfile
        _string_to_file( outfile,result_string)
    return summary, result_string, outfile
    
def _get_file_name(data):
    undefined = "UNDEFINED"
    source = ""
    created = undefined
    keys = data.keys()
    if 'source' in keys:
        source = data['source']
    if 'reftime' in keys:
        created = data['created']
        created = datetime.datetime.fromtimestamp(created / 1e3)
        created = str(created).replace(":","_")
    elif 'created' in keys:
        created = data['created']
        created = datetime.datetime.fromtimestamp(created / 1e3)
        created = str(created).replace(":","_")
    return source+"_"+created
    
def _extract_summary(data):
    results= {}
    for k in data.keys():
        if k != "rows":
            results[k] = data[k];
    return results

def _file_to_string(filename):
  with open(filename, 'r') as f:
            return f.read()
    
def _string_to_file(filename, data):
  with open(filename, 'w') as f:
        f.write(data)


def _copy_js_css(target_dir):
    for f in TEMPLATE_JS_CSS:
        path = JS_CSS_PATH + str(f)
        file_str = assets.get_asset_string(path)
        _string_to_file(Path(target_dir)/f,file_str)

def _config_from_args():
    parser = argparse.ArgumentParser(description="""Utility function generating HTML files from JSON forecast files (the output of machine learning models). for converting logged data from the solar farm.
                                     
EXAMPLE: 
>python -m apollo.server.html -i forecast_json -o html\solar\forecasts 
""")
    parser.add_argument('-i', '--in', metavar='in', type=str, nargs=1,dest='indir',
                        default=None,required=True,
                        help='the directory containing JSON forecasts for process.')
    parser.add_argument('-o', '--out', metavar='out', type=str, nargs=1,dest='outdir',
                        default=None,required=True,
                        help='the directory to store the generated HTML files.')
    parser.add_argument('-n', '--index', metavar='index', type=str, nargs=1,
                        dest='index',default="index.html",
                        help='the name of the index file ("index.html" by default).')
    parser.add_argument('-t', '--template', metavar='index', 
                        type=str, nargs=1,dest='template',
                        default="forecast.html",
                        help='the name of the template file to insert the JSON into ("forecast.html" by default).')
    parser.add_argument('--log', type=str, default='INFO', 
                        help='Sets the log level. One of INFO, DEBUG, ERROR, etc. Default is INFO')
    
    args = parser.parse_args()

    logging.basicConfig(format='[{asctime}] {levelname}: {message}', style='{', level=args.log)
    

    if isinstance(args.indir,list):
        args.indir = args.indir[0]
    if isinstance(args.outdir,list):
        args.outdir = args.outdir[0]
    if isinstance(args.index,list):
        args.index = args.index[0]
    if isinstance(args.template,list):
        args.template = args.template[0]
        
    logging.info(" * in:" +str(args.indir))
    logging.info(" * out:"+str(args.outdir))
    logging.info(" * index:"+str(args.index))
    logging.info(" * template:"+str(args.template))
    return args

if __name__ == "__main__":
  args = _config_from_args()
  process_directory(Path(args.indir),Path(args.outdir), Path(args.index), Path(args.template))
  pass
  
  
  