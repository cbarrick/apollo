# -*- coding: utf-8 -*-
"""
Generates GHI, DNI, and DHI forecasts using `PVLIB-Python`_ , based on 
GFS, HRRR_ESRL, NAM, NDFD, HRRR, or RAP models. 

This modules is intended to be used by the Apollo web server. A query 
(requesting a forecast) is made to the server, and the results are formated as JSON 
and returned. 

To generate a forecast, an instance of :class:`PVLibForecastWrapper` is created,  
specifying the model name (a string, e.g., ``'NAM;`` or ``'GFS25;``), latitude and longitude, and 
the starting and stopping timestamps. The method :func:`PVLibForecastWrapper.forecast` 
is then invoked.  

Internally, an appropriate PVLIB-Python `forecast model`_ instance is created, 
and its :func:`get_processed_data` method called. The results are either returned as 
as :class:`pandas.DataFrame` or else as a dictionary encoding both the tabular data and 
metadata for each column in the results. The start and end times can be omitted from
the initial query, in which 
case a 7 day period is used beginning on the current day's date. For instance: 

>>> m = PVLibForecastWrapper(model_name = "NAM", latitude = 33.8693, longitude = -83.44993)
>>> df = m.forecast()

Timestamps can be represented in any form compatible with :func:`pandas.to_datetime`, 
though integer values are assumed to represent milliseconds since 00:00:00 January 1, 1970 UTC. 
If the resulting timestamp has no timezone information, it is localized to ``pytz.utc``.

 >>> df = m.get_forecast(model_name = "GFS50", latitude = 33.8693, longitude = -83.44993,start='2019-04-02', stop = '2019-04-05')

By default, :func:`PVLibForecastWrapper.forecast` returns a :class:`pandas.DataFrame` object. 
The alternative, a Python dictionary, is used by the Apollo server to present 
results over the Web, and the results are formatted with that in mind (e.g., 
timestamps are represented as integers to be parsed by Javascript). 
The dictionary can be generated by invoking  :func:`PVLibForecastWrapper.format_results`.

>>> results = m.format_results()

.. code-block:: python

    {
    'start': 1554336000000.0, 
    'stop': 1554940800000.0, 
    'latitude': 33.8693, 
    'longitude': -83.44993, 
    'model': 'NAM', 
    'columns': [{'label': 'TIMESTAMP', 'units': '', 'description': 'TIMESTAMP', 'type': 'datetime'}, 
    			{'label': 'Air Temperature', 'units': '', 'description': 'Air Temperature', 'type': 'number'}, 
    			{'label': 'Wind Speed', 'units': '', 'description': 'Wind Speed', 'type': 'number'}, 
    			{'label': 'GHI', 'units': '', 'description': 'GHI', 'type': 'number'}, 
    			{'label': 'DNI', 'units': '', 'description': 'DNI', 'type': 'number'}, 
    			{'label': 'DHI', 'units': '', 'description': 'DHI', 'type': 'number'}, 
    			{'label': 'Total Clouds', 'units': '', 'description': 'Total Clouds', 'type': 'number'}, 
    			{'label': 'Low Clouds', 'units': '', 'description': 'Low Clouds', 'type': 'number'}, 
    			{'label': 'Mid Clouds', 'units': '', 'description': 'Mid Clouds', 'type': 'number'}, 
    			{'label': 'High Clouds', 'units': '', 'description': 'High Clouds', 'type': 'number'}
    			], 
    'rows': [ ...],
    'site': 'PVLib Forecast (latitude: 33.8693, longitude: -83.44993)', 
    'title': 'PVLIB Python', 
    'units': '', 
    'subtitle': 'NAM'
    }


.. _`forecast model`: https://pvlib-python.readthedocs.io/en/latest/forecasts.html
.. _`PVLIB-Python`: https://pvlib-python.readthedocs.io/

In the ususual scenario, this module would be called by :mod:``apollo.server.solarserver``
in the course of responding to certain requests, such as the one given below. 


``http://127.0.0.1:5000/pvlib?pvlib&model=GFS25&site7Alapaha&``
``start=1554782400000&stop=1555387200000&latitude=31.3447&longitude=-83.24072``

"""
import datetime
import numpy as np
import pandas as pd
import logging
import pytz
from pvlib.forecast import GFS, HRRR_ESRL, NAM, NDFD, HRRR, RAP

logger = logging.getLogger(__name__)

# keys for the formatted output dictionary. 
OUTPUT_SITE_KEY =       "site"
OUTPUT_TITLE_KEY =      "title"
OUTPUT_SUBTITLE_KEY =   "subtitle"
OUTPUT_ROWS_KEY =       "rows"
OUTPUT_COLUMNS_KEY =    "columns"
OUTPUT_START_TIME_KEY = "start"
OUTPUT_STOP_TIME_KEY =  "stop"
OUTPUT_UNITS_KEY =      "units"
OUTPUT_LAT_KEY =      "latitude"
OUTPUT_LON_KEY =      "longitude"
OUTPUT_MODEL_KEY =      "model"

# keys for descrbing each column of the results. 
OUTPUT_COLUMN_ATTRIBUTE_LABEL_KEY =      "label"
OUTPUT_COLUMN_ATTRIBUTE_DESCRIPTION_KEY = "description"
OUTPUT_COLUMN_ATTRIBUTE_UNITS_KEY =     "units"
OUTPUT_COLUMN_ATTRIBUTE_DATATYPE_KEY =  "type"


class PVLibForecastWrapper():
    """Wrapper class for forecast generation methods, with attributes 
    relevant to the forecast. These can be accessed and modified 
    by accessing the appropriate instance variable. 
    
    The results of :func:`PVLibForecastWrapper.forecast` are stored in 
    ``self.results``. 

    Arguments:
        model_name (str): The model type.
        model (float): The PVLIB-Python forecast model instance. 
        latitude (float): The latitude of the forecast location.
        longitude (float): The longitude of the forecast location. 
        start (str or int or Pandas.Timestamp): The beginning of the forecast interval.
        stop (str or int or Pandas.Timestamp): The end of the forecast interval. 
        formatted (bool): Whether forecasts should return formatted results. 
    """    
    def __init__(self, model_name = "NAM", 
                 latitude = 32.1656, 
                 longitude =  -82.9001, 
                 start = None, 
                 stop = None, 
                 formatted = False):
        self.model_name = model_name
        self.model = self._get_model_by_name(model_name)
        self.latitude = latitude
        self.longitude = longitude
        self.start = start
        self.stop = stop
        self.formatted=formatted
        self.results = None
        
    def forecast(self):
        """Generate a forecast using the underlying PVLIB-Python forecast model. 

        The :func:`get_processed_data` method of the PVIB-Python model is called, 
        and the results are returned as a :class:`pandas.DataFrame`.

        Returns:
            :class:`pandas.DataFrame`:
                The results of the forecast. 
        """
        self.start, self.stop = self._get_start_stop_dates(self.start, self.stop)
        
        logger.debug(f"{self.model_name}:{self.start}-{self.stop},{self.latitude},{self.longitude}")

        self.results = self.model.get_processed_data(self.latitude, self.longitude, self.start, self.stop)
        
        if self.formatted:
            response_dictionary = self.format_results()
            return response_dictionary
        return self.results    


   
    def _get_model_by_name(self, model_name = "NAM"):
        """Creates a PVLib model instance associated with the given name. 
        
        Arguments:
            model_name (str): The name of the model, one of "GFS25", "GFS50", "HRRR_ESRL", "NAM", "NDFD", "HRRR", "RAP20", or "RAP40".
    
        Returns:
            :class:`pvlib.forecast.ForecastModel`:
                An instance of the PVlib weather model. 
        """
        if "NAM" == model_name:
            return NAM()    
        elif "GFS25" == model_name:
           return GFS(resolution='quarter')
        elif "GFS50" == model_name:
            return  GFS(resolution='half')
        elif "HRRR" == model_name:
            return  HRRR()    
        elif "HRRR_ESRL" == model_name:
            return  HRRR_ESRL()    
        elif "NDFD" == model_name:
            return  NDFD()
        elif "RAP20" == model_name:
            return  RAP(resolution='20')
        elif "RAP40" == model_name:
            return  RAP(resolution='40')
        return None        
            
    def _get_start_stop_dates(self, start, stop):
        """Generates pandas.Timestamp instances based on ``start`` and ``stop``.
        
        Attempts to parse the times. If integers, they are assumed to be the 
        number of ms since Jan 1 1970. If strings, they are parsed. If already 
        pandas.Timestamp instances, they are returned. If no timezone information 
        was provided, the timestamps are localized to UTC. 
        
        If invalid dates are given, including if start > stop, then defaults to 
        start = now and stop = now+7 days. 

        Arguments:
            start (int or str or pandas.Timestamp): The start of the forecast. If an int, then ms since Jan 1 1970. 
            stop (int or str or pandas.Timestamp): The end of the forecast.  If an int, then ms since Jan 1 1970. 

        Returns:
            pandas.Timestamp,pandas.Timestamp:
                Starting and ending timestamps. 
         """
        start = self._get_date(start)
        stop = self._get_date(stop)

        if start == None:
            start = pd.Timestamp(datetime.date.today()).tz_localize(pytz.utc)
        if stop == None:
            stop = (start + pd.Timedelta(days=7))
        if start >= stop:
            stop = (start + pd.Timedelta(days=7))
        return start,stop

    def _get_date(self, ts):
        """Generates a pandas.Timestamp instance based on the date given. 
        
        If an integer, then it is assumed to be the 
        number of milliseconds since midnight Jan 1 1970. If a string, then it 
        is parsed using pandas.to_datetime. If it is a 
        ``Timestamp``, then it is returned. If the timestamp has no timezone 
        information, it is set to UTC. If an invalid date is given, then 
        ``None`` is returned. 
        
        Arguments:
            ts (int or str or pandas.Timestamp): A representation of the timestamp to generate.  
    
        Returns:  
            pandas.Timestamp:
                a representation of a timestamp. 
        """
        if isinstance(ts, pd.Timestamp):
            if ts.tzinfo == None:
                return ts.tz_localize(pytz.utc)
        try:
            return pd.to_datetime(int(ts), unit='ms').tz_localize(pytz.utc)
        except:
            try:
                ts = pd.to_datetime(ts)
                if ts.tzinfo == None:
                    ts = ts.tz_localize(pytz.utc)
                return ts
            except:
                return None
        
    def format_results(self):
        """Formats the results of the forecast as a Python dictionary, encoding
        metadata for each column in the results. See the above description for
        for format. 
        
        Returns:
            dict:
                a dictionary encoding the results. 
        """
               
        if not isinstance(self.results,pd.DataFrame):
            return None
        # convert to ms since Jan 1 1970
        start = self.start.value / int(1e6)
        stop = self.stop.value / int(1e6)
        
        column_names = [str(c) for c in self.results]
        columns = [{OUTPUT_COLUMN_ATTRIBUTE_LABEL_KEY:self._get_label(c),
                    OUTPUT_COLUMN_ATTRIBUTE_UNITS_KEY:"",
                    OUTPUT_COLUMN_ATTRIBUTE_DESCRIPTION_KEY:self._get_label(c),
                    OUTPUT_COLUMN_ATTRIBUTE_DATATYPE_KEY:"number"} 
                        for c in column_names]
        
        self.results.insert(0, 'TIMESTAMP', self.results.index.astype(np.int64)/int(1e6))
        columns.insert(0, {OUTPUT_COLUMN_ATTRIBUTE_LABEL_KEY:'TIMESTAMP',
                           OUTPUT_COLUMN_ATTRIBUTE_UNITS_KEY:"",
                           OUTPUT_COLUMN_ATTRIBUTE_DESCRIPTION_KEY:'TIMESTAMP',
                           OUTPUT_COLUMN_ATTRIBUTE_DATATYPE_KEY:"datetime"})
        
        rows = self.results.values.tolist()   
        
        latlng = ""
        if self.latitude and self.longitude:
            latlng = f"(latitude: {str(self.latitude)}, longitude: {str(self.longitude)})"
            
        # There's some redundancy in what's returned. 
        return  {
            OUTPUT_START_TIME_KEY: start,
            OUTPUT_STOP_TIME_KEY:  stop,
            OUTPUT_LAT_KEY :      self.latitude,
            OUTPUT_LON_KEY :      self.longitude,
            OUTPUT_MODEL_KEY :      self.model_name,
            OUTPUT_COLUMNS_KEY:  columns,
            OUTPUT_ROWS_KEY:  rows,
            OUTPUT_SITE_KEY:  "PVLib Forecast " + latlng,
            OUTPUT_TITLE_KEY:  "PVLIB Python",
            OUTPUT_UNITS_KEY:  "",
            OUTPUT_SUBTITLE_KEY:  self.model_name}


    def _get_label(self,attr):
        """Return a human-readable label for an attribute. If no match is found, 
        this simply replaces each ``_`` with a space 
        and capitalizes each word in the string. 
        
        Arguments:
            attr (str): The attribute to process.
        
        Returns:
            str:
                a label for the attribute. 
        """
        if "temp_air" == attr:
            return "Air Temperature"
        if "ghi" == attr:
            return "GHI"
        if "dni" == attr:
            return "DNI"
        if "dhi" == attr:
            return "DHI"
        return str(attr).replace("_"," ").title()
